(******************************************************************************)
(* A library for lists                                                        *)
(*                                                                            *)
(* It mainly follows the Haskell List-library                                 *)
(******************************************************************************)



(* ========================================================================== *)
(* Header                                                                     *)
(* ========================================================================== *)


(* rename module to clash with existing list modules of targets
   problem: renaming from inside the module itself! *)

(* declare rename module = lem_list *)

open import Bool Maybe Basic_classes Tuple Num


(* ========================================================================== *)
(* Basic list functions                                                       *)
(* ========================================================================== *)

(* The type of lists as well as list literals like [], [1;2], ... are hardcoded. 
   Thus, we can directly dive into derived definitions. *)


(* ----------------------- *)
(* cons                    *)
(* ----------------------- *)

val (::) : forall 'a. 'a -> list 'a -> list 'a

declare ascii_rep function (::) = cons
declare hol      target_rep function cons = infix `::`
declare ocaml    target_rep function cons = infix `::`
declare isabelle target_rep function cons = infix `#`
declare coq      target_rep function cons = infix `::`


(* ----------------------- *)
(* Emptyness check         *)
(* ----------------------- *)

val null : forall 'a. list 'a -> bool
let null l = match l with [] -> true | _ -> false end

declare hol target_rep function null = `NULL`

assert null_simple_1: (null [])
assert null_simple_2: (not (null [2;3;4]))
assert null_simple_3: (not (null [2]))

(* ----------------------- *)
(* Length                  *)
(* ----------------------- *)

val length : forall 'a. list 'a -> num
let rec length l = match l with
                     | [] -> 0
                     | x :: xs -> length xs + 1
                   end

declare termination_argument length = automatic

declare hol      target_rep function length = `LENGTH`
declare ocaml    target_rep function length = `List.length`
declare isabelle target_rep function length = `List.length`
declare coq      target_rep function length = `List.length`

assert length_0: (length [] = 0)
assert length_1: (length [2] = 1)
assert length_2: (length [2;3] = 2)

lemma length_spec: ((length [] = 0) && (forall x xs. length (x :: xs) = length xs + 1))

(* ----------------------- *)
(* Equality                *)
(* ----------------------- *)

val listEq : forall 'a. Eq 'a => list 'a -> list 'a -> bool
val listEqBy : forall 'a. ('a -> 'a -> bool) -> list 'a -> list 'a -> bool

let rec listEqBy eq l1 l2 = match (l1,l2) with
  | ([], []) -> true
  | ([], (_::_)) -> false
  | ((_::_), []) -> false
  | (x::xs, y :: ys) -> (eq x y && listEqBy eq xs ys)
end
let listEq = listEqBy (=)

instance forall 'a. Eq 'a => (Eq (list 'a))
  let (=) = listEq
end


(* ----------------------- *)
(* compare                 *)
(* ----------------------- *)

val lexicographicCompare : forall 'a. Ord 'a => list 'a -> list 'a -> ordering
val lexicographicCompareBy : forall 'a. ('a -> 'a -> ordering) -> list 'a -> list 'a -> ordering

let rec lexicographicCompareBy cmp l1 l2 = match (l1,l2) with
  | ([], []) -> EQ
  | ([], _::_) -> LT
  | (_::_, []) -> GT
  | (x::xs, y::ys) -> begin
      match cmp x y with 
        | LT -> LT
        | GT -> GT
        | EQ -> lexicographicCompareBy cmp xs ys
      end
    end
end
let lexicographicCompare = lexicographicCompareBy compare

instance forall 'a. Ord 'a => (Ord (list 'a))
  let compare = lexicographicCompare
end



(* ----------------------- *)
(* Append                  *)
(* ----------------------- *)

val (++) : forall 'a. list 'a -> list 'a -> list 'a (* originally append *)
let rec (++) xs ys = match xs with
                     | [] -> ys
                     | x :: xs' -> x :: (xs' ++ ys)
                   end
declare termination_argument append = automatic
declare ascii_rep function (++) = append

declare hol      target_rep function append = infix `++`
declare ocaml    target_rep function append = `List.append`
declare isabelle target_rep function append = infix `@`
declare coq      target_rep function append = `List.app`

assert append_1: ([0;1;2;3] ++ [4;5] = [0;1;2;3;4;5])
lemma append_nil_1: (forall l. l ++ [] = l)
lemma append_nil_2: (forall l. [] ++ l = l)

(* ----------------------- *)
(* snoc                    *)
(* ----------------------- *)

val snoc : forall 'a. 'a -> list 'a -> list 'a
let snoc e l = l ++ [e]

declare hol      target_rep function snoc = `SNOC`
let inline {isabelle;coq} snoc e l = l ++ [e]

(* ----------------------- *)
(* Map                     *)
(* ----------------------- *)

val map : forall 'a 'b. ('a -> 'b) -> list 'a -> list 'b
let rec map f l = match l with
  | [] -> []
  | x :: xs -> (f x) :: map f xs
end
declare termination_argument map = automatic

declare hol      target_rep function map = `MAP`
declare ocaml    target_rep function map = `List.map`
declare isabelle target_rep function map = `List.map`
declare coq      target_rep function map = `List.map`

assert map_nil: (map (fun x -> x + 1) [] = [])
assert map_1: (map (fun x -> x + 1) [0] = [1])
assert map_4: (map (fun x -> x + 1) [0;1;2;3] = [1;2;3;4])

(* ----------------------- *)
(* Reverse                 *)
(* ----------------------- *)

(* First lets define the function [reverse_append], which is
   closely related to reverse. [reverse_append l1 l2] appends the list [l2] to the reverse of [l1].
   This can be implemented more efficienctly than appending and is
   used to implement reverse. *)

val reverseAppend : forall 'a. list 'a -> list 'a -> list 'a (* originally named rev_append *)
let rec reverseAppend l1 l2 = match l1 with 
                                | [] -> l2
                                | x :: xs -> reverseAppend xs (x :: l2)
                               end
declare termination_argument reverseAppend = automatic

declare hol      target_rep function reverseAppend = `REV`
declare ocaml    target_rep function reverseAppend = `List.rev_append`

assert reverseAppend_1: (reverseAppend [0;1;2;3] [4;5] = [3;2;1;0;4;5])

(* Reversing a list *)
val reverse : forall 'a. list 'a -> list 'a (* originally named rev *)
let reverse l = reverseAppend l [] 

declare hol      target_rep function reverse = `REVERSE`
declare ocaml    target_rep function reverse = `List.rev`
declare isabelle target_rep function reverse = `List.rev`
declare coq      target_rep function reverse = `List.rev`

assert reverse_nil: (reverse [] = [])
assert reverse_1: (reverse [1] = [1])
assert reverse_2: (reverse [1;2] = [2;1])
assert reverse_5: (reverse [1;2;3;4;5] = [5;4;3;2;1])

lemma reverseAppend: (forall l1 l2. reverseAppend l1 l2 = append (reverse l1) l2)


(* ----------------------- *)
(* Reverse Map             *)
(* ----------------------- *)

val reverseMap : forall 'a 'b. ('a -> 'b) -> list 'a -> list 'b
let reverseMap f l = reverse (map f l)

declare ocaml target_rep function reverseMap = `List.rev_map`



(* ========================================================================== *)
(* Folding                                                                    *)
(* ========================================================================== *)

(* ----------------------- *)
(* fold left               *)
(* ----------------------- *)

val foldl : forall 'a 'b. ('a -> 'b -> 'a) -> 'a -> list 'b -> 'a (* originally foldl *)

let rec foldl f b l = match l with
  | []      -> b
  | x :: xs -> foldl f (f b x) xs
end
declare termination_argument foldl = automatic

declare hol      target_rep function foldl = `FOLDL`
declare ocaml    target_rep function foldl = `List.fold_left`
declare isabelle target_rep function foldl = `List.foldl`
declare coq      target_rep function foldl f e l = `List.fold_left` f l e

assert foldl_0: (foldl (+) 0 [] = 0)
assert foldl_1: (foldl (+) 0 [4] = 4)
assert foldl_4: (foldl (fun l e -> e::l) [] [1;2;3;4] = [4;3;2;1])


(* ----------------------- *)
(* fold right              *)
(* ----------------------- *)

val foldr : forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> list 'a -> 'b (* originally foldr with different argument order *)
let rec foldr f b l = match l with
  | []      -> b
  | x :: xs -> f x (foldr f b xs)
end
declare termination_argument foldr = automatic

declare hol      target_rep function foldr = `FOLDR` 
declare ocaml    target_rep function foldr f b l = `List.fold_right` f l b
declare isabelle target_rep function foldr f b l = `List.foldr` f l b
declare coq      target_rep function foldr = `List.fold_right` 

assert fold_right_0: (foldr (+) 0 [] = 0)
assert fold_right_1: (foldr (+) 1 [4] = 5)
assert fold_right_4: (foldr (fun e l -> e::l) [] [1;2;3;4] = [1;2;3;4])


(* ----------------------- *)
(* concatenating lists     *)
(* ----------------------- *)

val concat : forall 'a. list (list 'a) -> list 'a (* before also called "flatten" *)
let concat = foldr append []

declare hol      target_rep function concat = `FLAT`
declare ocaml    target_rep function concat = `List.concat`
declare isabelle target_rep function concat = `List.concat`
declare coq      target_rep function concat = `List.flat_map` (fun x -> x)

assert concat_nil: (concat [] = [])
assert concat_1: (concat [[1]] = [1])
assert concat_2: (concat [[1];[2]] = [1;2])
assert concat_3: (concat [[1];[];[2]] = [1;2])

lemma concat_emp_thm: (concat [] = [])
lemma concat_cons_thm: (forall l ll. (concat (l::ll) = append l (concat ll)))


(* -------------------------- *)
(* concatenating with mapping *)
(* -------------------------- *)

val concatMap : forall 'a 'b. ('a -> list 'b) -> list 'a -> list 'b
let concatMap f = foldr (fun l ll -> f l ++ ll) []

assert concatMap_nil: (concatMap (fun x -> [x;x]) [] = [])
assert concatMap_1: (concatMap (fun x -> [x;x]) [1] = [1;1])
assert concatMap_2: (concatMap (fun x -> [x;x]) [1;2] = [1;1;2;2])
assert concatMap_3: (concatMap (fun x -> [x;x]) [1;2;3] = [1;1;2;2;3;3])
lemma concatMap_concat: (forall ll. concat ll = concatMap (fun l -> l) ll)


(* ------------------------- *)
(* universal qualification   *)
(* ------------------------- *)

val all : forall 'a. ('a -> bool) -> list 'a -> bool (* originally for_all *)
let all P l = foldl (fun r e -> P e && r) true l

declare hol      target_rep function all = `EVERY`
declare ocaml    target_rep function all = `List.all`
declare isabelle target_rep function all P l = (forall (x IN (`set` l)). P x)
declare coq      target_rep function all = `List.forallb` 

assert all_0: (all (fun x -> x > 2) [])
assert all_4: (all (fun x -> x > 2) [4;5;6;7])
assert all_4_neg: (not (all (fun x -> x > 2) [4;5;2;7]))

lemma all_nil_thm: (forall P. all P [])
lemma all_cons_thm: (forall P e l. all P (e::l) = (P e && all P l))



(* ------------------------- *)
(* existential qualification *)
(* ------------------------- *)

val any : forall 'a. ('a -> bool) -> list 'a -> bool (* originally exist *)
let any P l = foldl (fun r e -> P e || r) false l

declare hol      target_rep function any = `EXISTS`
declare ocaml    target_rep function any = `List.exists`
declare isabelle target_rep function any P l = (exists (x IN (`set` l)). P x)
declare coq      target_rep function any = `List.existsb` 

assert any_0: (not (any (fun x -> (x < 3)) []))
assert any_4: (not (any (fun x -> (x < 3)) [4;5;6;7]))
assert any_4_neg: (any (fun x -> (x < 3)) [4;5;2;7])

lemma any_nil_thm: (forall P. not (any P []))
lemma any_cons_thm: (forall P e l. any P (e::l) = (P e || any P l))


(* ========================================================================== *)
(* Indexing lists                                                             *)
(* ========================================================================== *)

(* ------------------------- *)
(* index / nth with maybe   *)
(* ------------------------- *)

val index : forall 'a. list 'a -> num -> maybe 'a

let rec index l n = match l with 
  | []      -> Nothing
  | x :: xs -> if n = 0 then Just x else index xs (n-1)
end


declare termination_argument index = automatic

assert index_0: (index [0;1;2;3;4;5] 0 = Just 0)
assert index_1: (index [0;1;2;3;4;5] 1 = Just 1)
assert index_2: (index [0;1;2;3;4;5] 2 = Just 2)
assert index_3: (index [0;1;2;3;4;5] 3 = Just 3)
assert index_4: (index [0;1;2;3;4;5] 4 = Just 4)
assert index_5: (index [0;1;2;3;4;5] 5 = Just 5)
assert index_6: (index [0;1;2;3;4;5] 6 = Nothing)

lemma index_is_none: (forall l n. (index l n = Nothing) <-> (n >= length l))
lemma index_list_eq: (forall l1 l2. ((forall n. index l1 n = index l2 n) <-> (l1 = l2)))

(* ------------------------- *)
(* findIndices               *)
(* ------------------------- *)

(* [findIndices P l] returns the indices of all elements of list [l] that satisfy predicate [P]. 
   Counting starts with 0, the result list is sorted ascendingly *)
val findIndices : forall 'a. ('a -> bool) -> list 'a -> list num

let rec findIndices_aux i P l =
  match l with
    | []      -> []
    | x :: xs -> if P x then i :: findIndices_aux (i + 1) P xs else findIndices_aux (i + 1) P xs
 end
let findIndices = findIndices_aux 0

assert findIndices_1: (findIndices (fun n -> n > 3) [] = [])
assert findIndices_2: (findIndices (fun n -> n > 3) [4] = [0])
assert findIndices_3: (findIndices (fun n -> n > 3) [1;5;3;1;2;6] = [1;5])



(* ------------------------- *)
(* findIndex                 *)
(* ------------------------- *)

(* findIndex returns the first index of a list that satisfies a given predicate. *)
val findIndex : forall 'a. ('a -> bool) -> list 'a -> maybe num
let findIndex P l = match findIndices P l with
  | [] -> Nothing
  | x :: _ -> Just x
end

(* ------------------------- *)
(* elemIndices               *)
(* ------------------------- *)

val elemIndices : forall 'a. Eq 'a => 'a -> list 'a -> list num
let elemIndices e l = findIndices (isEqual e) l

(* ------------------------- *)
(* elemIndex                 *)
(* ------------------------- *)

val elemIndex : forall 'a. Eq 'a => 'a -> list 'a -> maybe num
let elemIndex e l = findIndex ((=) e) l



(* ========================================================================== *)
(* Creating lists                                                             *)
(* ========================================================================== *)

(* ------------------------- *)
(* genlist                   *)
(* ------------------------- *)

(* [genlist f n] generates the list [f 0; f 1; ... (f (n-1))] *)
val genlist : forall 'a. (num -> 'a) -> num -> list 'a


let rec genlist f n = if n = 0 then [] else snoc (f (n-1)) (genlist f (n-1))
declare termination_argument genlist = automatic

assert genlist_0: (genlist (fun n -> n) 0 = [])
assert genlist_1: (genlist (fun n -> n) 1 = [0])
assert genlist_2: (genlist (fun n -> n) 2 = [0;1])
assert genlist_3: (genlist (fun n -> n) 3 = [0;1;2])
lemma genlist_length: (forall f n. (length (genlist f n) = n))
lemma genlist_index: (forall f n i. i < n --> index (genlist f n) i = Just (f i))


declare hol target_rep function genlist = `GENLIST`


(* ------------------------- *)
(* replicate                 *)
(* ------------------------- *)

val replicate : forall 'a. num -> 'a -> list 'a
let rec replicate n x = if n = 0 then [] else x :: replicate (n-1) x
declare termination_argument replicate = automatic

declare isabelle target_rep function replicate = `List.replicate`

assert replicate_0: (replicate 0 2 = [])
assert replicate_1: (replicate 1 2 = [2])
assert replicate_2: (replicate 2 2 = [2;2])
assert replicate_3: (replicate 3 2 = [2;2;2])
lemma replicate_length: (forall n x. (length (replicate n x) = n))
lemma replicate_index: (forall n x i. i < n --> index (replicate n x) i = Just x)


(* ========================================================================== *)
(* Sublists                                                                   *)
(* ========================================================================== *)

(* ------------------------- *)
(* splitAt                   *)
(* ------------------------- *)

(* [splitAt n xs] returns a tuple (xs1, xs2), with "append xs1 xs2 = xs" and 
   "length xs1 = n". If there are not enough elements 
   in [xs], the original list and the empty one are returned. *)
val splitAt : forall 'a. num -> list 'a -> (list 'a * list 'a)
let rec splitAt n l = 
  match l with
    | []    -> ([], [])
    | x::xs -> 
       if n <= 0 then ([], l) else
       begin
         let (l1, l2) = splitAt (n-1) l in
         (x::l1, l2)
       end    
  end

assert splitAt_1: (splitAt 0   [1;2;3;4;5;6] = ([], [1;2;3;4;5;6]))
assert splitAt_2: (splitAt 2   [1;2;3;4;5;6] = ([1;2], [3;4;5;6]))
assert splitAt_3: (splitAt 100 [1;2;3;4;5;6] = ([1;2;3;4;5;6], []))

lemma splitAt_append: (forall n xs.
  let (xs1, xs2) = splitAt n xs in 
  (xs = xs1 ++ xs2))

lemma splitAt_length: (forall n xs. 
  let (xs1, xs2) = splitAt n xs in 
  ((length xs1 = n) ||
   ((length xs1 = length xs) && null xs2)))


(* ------------------------- *)
(* take                      *)
(* ------------------------- *)

(* take n xs returns the prefix of xs of length n, or xs itself if n > length xs *)
val take : forall 'a. num -> list 'a -> list 'a
let take n l = fst (splitAt n l)

declare hol      target_rep function take = `TAKE`
declare isabelle target_rep function take = `List.take`

assert take_1: (take 0   [1;2;3;4;5;6] = [])
assert take_2: (take 2   [1;2;3;4;5;6] = [1;2])
assert take_3: (take 100 [1;2;3;4;5;6] = [1;2;3;4;5;6])



(* ------------------------- *)
(* drop                      *)
(* ------------------------- *)

(* [drop n xs] drops the first [n] elements of [xs]. It returns the empty list, if [n] > [length xs]. *)
val drop : forall 'a. num -> list 'a -> list 'a
let drop n l = snd (splitAt n l)

declare hol      target_rep function drop = `DROP`
declare isabelle target_rep function drop = `List.drop`

assert drop_1: (drop 0   [1;2;3;4;5;6] = [1;2;3;4;5;6])
assert drop_2: (drop 2   [1;2;3;4;5;6] = [3;4;5;6])
assert drop_3: (drop 100 [1;2;3;4;5;6] = [])

lemma splitAt_take_drop: (forall n xs. splitAt n xs = (take n xs, drop n xs))


(* ------------------------- *)
(* update                    *)
(* ------------------------- *)
val update : forall 'a. list 'a -> num -> 'a -> list 'a
let rec update l n e = 
  match l with
    | []      -> []
    | x :: xs -> if n = 0 then e :: xs else x :: (update xs (n - 1) e)
end

declare isabelle target_rep function update = `List.list_update`
declare hol      target_rep function update l n e = `LUPDATE` e n l

assert list_update_1: (update [] 2 3 = [])
assert list_update_2: (update [1;2;3;4;5] 0 0 = [0;2;3;4;5])
assert list_update_3: (update [1;2;3;4;5] 1 0 = [1;0;3;4;5])
assert list_update_4: (update [1;2;3;4;5] 2 0 = [1;2;0;4;5])
assert list_update_5: (update [1;2;3;4;5] 5 0 = [1;2;3;4;5])

lemma list_update_length: (forall l n e. length (update l n e) = length l)
lemma list_update_index: (forall i l n e. 
  (index (update l n e) i = ((if i = n && n < length l then Just e else index l e))))



(* ========================================================================== *)
(* Searching lists                                                            *)
(* ========================================================================== *)

(* ------------------------- *)
(* Membership test           *)
(* ------------------------- *)

(* The membership test, one of the basic list functions, is actually tricky for
   Lem, because it is tricky, which equality to use. From Lem`s point of 
   perspective, we want to use the equality provided by the equality type - class.
   This allows for example to check whether a set is in a list of sets.

   However, in order to use the equality type class, elem essentially becomes
   existential quantification over lists. For types, which implement semantic
   equality (=) with syntactic equality, this is overly complicated. In
   our theorem prover backend, we would end up with overly complicated, harder
   to read definitions and some of the automation would be harder to apply.
   Moreover, nearly all the old Lem generated code would change and require 
   (hopefully minor) adaptions of proofs.

   For now, we ignore this problem and just demand, that all instances of
   the equality type class do the right thing for the theorem prover backends.   
*)

val elem : forall 'a. Eq 'a => 'a -> list 'a -> bool
val elemBy : forall 'a. ('a -> 'a -> bool) -> 'a -> list 'a -> bool

let elemBy eq e l = any (eq e) l
let elem = elemBy (=)

declare hol      target_rep function elem = `MEM`
declare ocaml    target_rep function elem = `List.mem`
declare isabelle target_rep function elem e l = `Set.member` e (`set` l)
declare coq      target_rep function elem = `List.forallb` 

assert elem_1: (elem 2 [3;1;2;4])
assert elem_2: (elem 3 [3;1;2;4])
assert elem_3: (elem 4 [3;1;2;4])
assert elem_4: (not (elem 5 [3;1;2;4]))

lemma elem_spec: ((forall e. not (elem e [])) &&
                  (forall e x xs. (elem e (x :: xs)) = ((e = x) || (elem e xs))))

(* ------------------------- *)
(* Find                      *)
(* ------------------------- *)
val find : forall 'a. ('a -> bool) -> list 'a -> maybe 'a (* previously not of maybe type *)
let rec find P l = match l with 
  | []      -> Nothing
  | x :: xs -> if P x then Just x else find P xs
end

declare isabelle target_rep function find = `List.find`

assert find_1: ((find (fun n -> n > 3) []) = Nothing)
assert find_2: ((find (fun n -> n > 3) [2;1;3]) = Nothing)
assert find_3: ((find (fun n -> n > 3) [2;1;5;4]) = Just 5)
assert find_4: ((find (fun n -> n > 3) [2;1;4;5;4]) = Just 4)

lemma find_in: (forall P l x. (find P l = Just x) --> P x && elem x l)
lemma find_not_in: (forall P l. (find P l = Nothing) = (not (any P l)))


(* ----------------------------- *)
(* Lookup in an associative list *)
(* ----------------------------- *)
val lookup   : forall 'a 'b. Eq 'a              => 'a -> list ('a * 'b) -> maybe 'b
val lookupBy : forall 'a 'b. ('a -> 'a -> bool) -> 'a -> list ('a * 'b) -> maybe 'b

let lookupBy eq k m = Maybe.map snd (find (fun (k', _) -> eq k k') m)
let inline lookup = lookupBy (=)


(* ------------------------- *)
(* filter                    *)
(* ------------------------- *)
val filter : forall 'a. ('a -> bool) -> list 'a -> list 'a
let rec filter P l = match l with
                       | [] -> []
                       | x :: xs -> if (P x) then x :: (filter P xs) else filter P xs
                     end
declare termination_argument filter = automatic

declare hol      target_rep function filter = `FILTER`
declare ocaml    target_rep function filter = `List.filter`
declare isabelle target_rep function filter = `List.filter`
declare coq      target_rep function filter = `List.filter`

assert filter_0: (filter (fun x -> x > 4) [] = [])
assert filter_1: (filter (fun x -> x > 4) [1;2;4;5;2;7;6] = [5;7;6])
lemma filter_nil_thm: (forall P. filter P [] = [])
lemma filter_cons_thm: (forall P x xs. filter P (x::xs) = (let l' = filter P xs in (if (P x) then x :: l' else l')))


(* ------------------------- *)
(* partition                 *)
(* ------------------------- *)
val partition : forall 'a. ('a -> bool) -> list 'a -> list 'a * list 'a
let partition P l = (filter P l, filter (fun x -> not (P x)) l)

val reversePartition : forall 'a. ('a -> bool) -> list 'a -> list 'a * list 'a
let reversePartition P l = partition P (reverse l)

let inline {hol} partition P l = reversePartition P (reverse l)
declare hol      target_rep function reversePartition p l = `PARTITION`
declare ocaml    target_rep function partition = `List.partition`
declare isabelle target_rep function partition = `List.partition`

assert partition_0: (partition (fun x -> x > 4) [] = ([], []))
assert partition_1: (partition (fun x -> x > 4) [1;2;4;5;2;7;6] = ([5;7;6], [1;2;4;2]))
lemma partition_fst: (forall P l. fst (partition P l) = filter P l)
lemma partition_snd: (forall P l. snd (partition P l) = filter (fun x -> not (P x)) l)


(* ------------------------- *)
(* delete first element      *)
(* with certain property     *)
(* ------------------------- *)

val deleteFirst : forall 'a. ('a -> bool) -> list 'a -> maybe (list 'a) 
let rec deleteFirst P l = match l with
                            | [] -> Nothing
                            | x :: xs -> if (P x) then Just xs else Maybe.map (fun xs' -> x :: xs') (deleteFirst P xs)
                          end
declare termination_argument deleteFirst = automatic

assert deleteFirst_1: (deleteFirst (fun x -> x > 5) [3;6;7;1] = Just [3;7;1])
assert deleteFirst_2: (deleteFirst (fun x -> x > 15) [3;6;7;1] = Nothing)
assert deleteFirst_3: (deleteFirst (fun x -> x > 2) [3;6;7;1] = Just [6;7;1])


val delete : forall 'a. Eq 'a => 'a -> list 'a -> list 'a
val deleteBy : forall 'a. ('a -> 'a -> bool) -> 'a -> list 'a -> list 'a

let deleteBy eq x l = fromMaybe l (deleteFirst (eq x) l)
let delete = deleteBy (=)

assert delete_1: (delete 6 [3;6;7;1] = [3;7;1])
assert delete_2: (delete 4 [3;6;7;1] = [3;6;7;1])
assert delete_3: (delete 3 [3;6;7;1] = [6;7;1])
assert delete_4: (delete 3 [3;3;6;7;1] = [3;6;7;1])


(* ========================================================================== *)
(* Zipping and unzipping lists                                                *)
(* ========================================================================== *)

(* ------------------------- *)
(* zip                       *)
(* ------------------------- *)

(* zip takes two lists and returns a list of corresponding pairs. If one input list is short, excess elements of the longer list are discarded. *)
val zip : forall 'a 'b. list 'a -> list 'b -> list ('a * 'b) (* before combine *)
let rec zip l1 l2 = match (l1, l2) with
  | (x :: xs, y :: ys) -> (x, y) :: zip xs ys
  | _ -> []
end

declare hol      target_rep function zip l1 l2 = `ZIP` (l1, l2)
declare isabelle target_rep function zip = `List.zip`

(* ------------------------- *)
(* unzip                     *)
(* ------------------------- *)

val unzip: forall 'a 'b. list ('a * 'b) -> (list 'a * list 'b)
let rec unzip l = match l with
  | [] -> ([], [])
  | (x, y) :: xys -> let (xs, ys) = unzip xys in (x :: xs, y :: ys)
end


(* ========================================================================== *)
(* Comments (not clean yet, please ignore the rest of the file)               *)
(* ========================================================================== *)

(* ----------------------- *)
(* skipped from Haskell Lib*)
(* ----------------------- 

intersperse :: a -> [a] -> [a]
intercalate :: [a] -> [[a]] -> [a]
transpose :: [[a]] -> [[a]]
subsequences :: [a] -> [[a]]
permutations :: [a] -> [[a]]
foldl` :: (a -> b -> a) -> a -> [b] -> aSource
foldl1` :: (a -> a -> a) -> [a] -> aSource

and
or
sum
product
maximum
minimum
scanl
scanr
scanl1
scanr1
Accumulating maps

mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])Source
mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])Source

iterate :: (a -> a) -> a -> [a]
repeat :: a -> [a]
cycle :: [a] -> [a]
unfoldr


takeWhile :: (a -> Bool) -> [a] -> [a]Source
dropWhile :: (a -> Bool) -> [a] -> [a]Source
dropWhileEnd :: (a -> Bool) -> [a] -> [a]Source
span :: (a -> Bool) -> [a] -> ([a], [a])Source
break :: (a -> Bool) -> [a] -> ([a], [a])Source
break p is equivalent to span (not . p).
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]Source
group :: Eq a => [a] -> [[a]]Source
inits :: [a] -> [[a]]Source
tails :: [a] -> [[a]]Source


isPrefixOf :: Eq a => [a] -> [a] -> BoolSource
isSuffixOf :: Eq a => [a] -> [a] -> BoolSource
isInfixOf :: Eq a => [a] -> [a] -> BoolSource



notElem :: Eq a => a -> [a] -> BoolSource

zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]Source
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]Source
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]Source
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]Source
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]Source

zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]Source
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]Source
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]Source
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]Source
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]Source
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]Source


unzip3 :: [(a, b, c)] -> ([a], [b], [c])Source
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])Source
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])Source
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])Source
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])Source


lines :: String -> [String]Source
words :: String -> [String]Source
unlines :: [String] -> StringSource
unwords :: [String] -> StringSource
nub :: Eq a => [a] -> [a]Source
delete :: Eq a => a -> [a] -> [a]Source

(\\) :: Eq a => [a] -> [a] -> [a]Source
union :: Eq a => [a] -> [a] -> [a]Source
intersect :: Eq a => [a] -> [a] -> [a]Source
sort :: Ord a => [a] -> [a]Source
insert :: Ord a => a -> [a] -> [a]Source


nubBy :: (a -> a -> Bool) -> [a] -> [a]Source
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]Source
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]Source
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]Source
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]Source
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]Source
sortBy :: (a -> a -> Ordering) -> [a] -> [a]Source
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]Source
maximumBy :: (a -> a -> Ordering) -> [a] -> aSource
minimumBy :: (a -> a -> Ordering) -> [a] -> aSource
genericLength :: Num i => [b] -> iSource
genericTake :: Integral i => i -> [a] -> [a]Source
genericDrop :: Integral i => i -> [a] -> [a]Source
genericSplitAt :: Integral i => i -> [b] -> ([b], [b])Source
genericIndex :: Integral a => [b] -> a -> bSource
genericReplicate :: Integral i => i -> a -> [a]Source


*)


(* ----------------------- *)
(* skipped from Lem Lib    *)
(* ----------------------- 


val for_all2 : forall 'a 'b. ('a -> 'b -> bool) -> list 'a -> list 'b -> bool
val exists2 : forall 'a 'b. ('a -> 'b -> bool) -> list 'a -> list 'b -> bool
val map2 : forall 'a 'b 'c. ('a -> 'b -> 'c) -> list 'a -> list 'b -> list 'c 
val rev_map2 : forall 'a 'b 'c. ('a -> 'b -> 'c) -> list 'a -> list 'b -> list 'c
val fold_left2 : forall 'a 'b 'c. ('a -> 'b -> 'c -> 'a) -> 'a -> list 'b -> list 'c -> 'a
val fold_right2 : forall 'a 'b 'c. ('a -> 'b -> 'c -> 'c) -> list 'a -> list 'b -> 'c -> 'c


(* now maybe result *)
val find : forall 'a. ('a -> bool) -> list 'a -> 'a 

(* now maybe result and called lookup *)
val assoc : forall 'a 'b. 'a -> list ('a * 'b) -> 'b
let inline {ocaml} assoc = Ocaml.List.assoc


val mem_assoc : forall 'a 'b. 'a -> list ('a * 'b) -> bool
val remove_assoc : forall 'a 'b. 'a -> list ('a * 'b) -> list ('a * 'b)



val stable_sort : forall 'a. ('a -> 'a -> num) -> list 'a -> list 'a
val fast_sort : forall 'a. ('a -> 'a -> num) -> list 'a -> list 'a

val merge : forall 'a. ('a -> 'a -> num) -> list 'a -> list 'a -> list 'a
val intersect : forall 'a. list 'a -> list 'a -> list 'a


*)
